# docker-compose.prod.yml - Production configuration with SSL
# Usage: docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d

services:
  # PostgreSQL with SSL enabled for production
  postgres:
    command:
      - postgres
      - -c
      - ssl=on                           # Enable SSL for production
      - -c
      - ssl_cert_file=/var/lib/postgresql/server.crt
      - -c
      - ssl_key_file=/var/lib/postgresql/server.key
      - -c
      - ssl_min_protocol_version=TLSv1.2  # Enforce modern TLS
      - -c
      - ssl_ciphers=HIGH:!aNULL:!MD5     # Strong ciphers only
      - -c
      - shared_preload_libraries=pgcrypto,pg_stat_statements
      - -c
      - max_connections=200               # Higher for production
      - -c
      - shared_buffers=1GB               # Production memory allocation
      - -c
      - effective_cache_size=3GB         # Assume dedicated server
      - -c
      - maintenance_work_mem=256MB       # Larger for maintenance tasks
      - -c
      - checkpoint_completion_target=0.7
      - -c
      - wal_buffers=64MB                 # Larger WAL buffers
      - -c
      - default_statistics_target=500    # Higher precision for optimizer
      - -c
      - random_page_cost=1.1             # SSD assumption
      - -c
      - effective_io_concurrency=200     # SSD setting
      - -c
      - work_mem=32MB                    # Memory for sorts/hashes
      - -c
      - max_wal_size=4GB                 # Larger WAL for busy systems
      - -c
      - min_wal_size=512MB
      - -c
      - log_min_duration_statement=5000  # Log very slow queries only
      - -c
      - log_checkpoints=on               # Monitor checkpoint performance
      - -c
      - log_connections=on               # Security monitoring
      - -c
      - log_disconnections=on
      - -c
      - log_lock_waits=on                # Detect lock contention
      - -c
      - deadlock_timeout=5s
      - -c
      - statement_timeout=300s           # Prevent runaway queries
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}  # Must be set in production
      POSTGRES_DB: notes
      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --locale=en_US.utf8"
    volumes:
      - postgres_prod_data:/var/lib/postgresql/data
      - ./ssl-certs:/var/lib/postgresql/ssl-certs:ro  # SSL certificates
      - ./init-ssl-prod.sh:/docker-entrypoint-initdb.d/00-init-ssl.sh:ro
    restart: always
    # Remove port exposure for production (access through backend only)
    # ports: []
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
        reservations:
          cpus: '1.0'
          memory: 2G

  # Redis with persistence and security for production
  redis:
    command: 
      - redis-server
      - --appendonly yes                 # Enable persistence
      - --appendfsync everysec           # Balance performance/durability
      - --save 900 1                     # Save if ‚â•1 key changed in 900s
      - --save 300 10                    # Save if ‚â•10 keys changed in 300s
      - --save 60 10000                  # Save if ‚â•10000 keys changed in 60s
      - --requirepass ${REDIS_PASSWORD}  # Must be set in production
      - --maxmemory 1gb                  # Limit memory usage
      - --maxmemory-policy allkeys-lru   # Evict least recently used keys
      - --tcp-keepalive 60               # Keep connections alive
      - --timeout 300                    # Client idle timeout
      - --maxclients 1000                # Connection limit
    volumes:
      - redis_prod_data:/data
    restart: always
    # Remove port exposure for production
    # ports: []
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M

  # Backend with production security settings
  backend:
    environment:
      DATABASE_URL: postgres://postgres:${POSTGRES_PASSWORD}@postgres:5432/notes?sslmode=require
      REDIS_URL: redis:6379
      REDIS_PASSWORD: ${REDIS_PASSWORD}
      JWT_SECRET: ${JWT_SECRET}          # Must be 64+ chars in production
      SERVER_ENCRYPTION_KEY: ${SERVER_ENCRYPTION_KEY}  # Must be 32 chars
      CORS_ORIGINS: ${CORS_ORIGINS}      # Restrict to production domains
      PORT: 8080
      LOG_LEVEL: info                    # Less verbose logging
      GO_ENV: production
      GIN_MODE: release                  # Production mode for Gin
    restart: always
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M
      replicas: 2                        # Multiple instances for HA

  # Frontend with production optimization
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      target: production                 # Use production stage
      args:
        VITE_API_URL: ${VITE_API_URL}
        NODE_ENV: production
    restart: always
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 128M

  # Nginx reverse proxy for production
  nginx:
    volumes:
      - ./nginx/nginx-prod.conf:/etc/nginx/nginx.conf:ro
      - ./ssl-certs:/etc/nginx/ssl:ro    # SSL certificates for HTTPS
      - ./nginx/dhparam.pem:/etc/nginx/dhparam.pem:ro  # Diffie-Hellman parameters
    restart: always
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 128M

  # SSL Certificate initialization for production
  ssl-init:
    image: alpine:latest
    container_name: secure-notes-ssl-init
    command: |
      sh -c "
        echo 'üîê Initializing SSL certificates for production...'
        apk add --no-cache openssl
        
        # Generate SSL certificates if they don't exist
        if [ ! -f /ssl-certs/server.key ]; then
          echo 'üìú Generating production SSL certificates...'
          
          # Generate strong private key
          openssl genpkey -algorithm RSA -out /ssl-certs/server.key -pkcs8 -aes256 -pass pass:temp
          openssl rsa -in /ssl-certs/server.key -out /ssl-certs/server.key -passin pass:temp
          
          # Generate certificate signing request
          openssl req -new -key /ssl-certs/server.key -out /ssl-certs/server.csr \
            -subj '/C=US/ST=State/L=City/O=SecureNotes/OU=Production/CN=${SSL_DOMAIN:-localhost}'
          
          # Generate self-signed certificate (replace with CA-signed cert in production)
          openssl x509 -req -days 365 -in /ssl-certs/server.csr \
            -signkey /ssl-certs/server.key -out /ssl-certs/server.crt \
            -extensions v3_req -extfile <(echo '[v3_req]'; echo 'subjectAltName=DNS:${SSL_DOMAIN:-localhost},DNS:www.${SSL_DOMAIN:-localhost}')
          
          # Generate Diffie-Hellman parameters for perfect forward secrecy
          openssl dhparam -out /nginx/dhparam.pem 2048
          
          # Set secure permissions
          chmod 600 /ssl-certs/server.key
          chmod 644 /ssl-certs/server.crt
          chmod 644 /nginx/dhparam.pem
          
          echo '‚úÖ SSL certificates generated successfully'
        fi
        
        # Validate required environment variables
        if [ -z '$POSTGRES_PASSWORD' ]; then
          echo '‚ùå ERROR: POSTGRES_PASSWORD must be set for production'
          exit 1
        fi
        
        if [ -z '$REDIS_PASSWORD' ]; then
          echo '‚ùå ERROR: REDIS_PASSWORD must be set for production'
          exit 1
        fi
        
        if [ -z '$JWT_SECRET' ] || [ '\${#JWT_SECRET}' -lt 64 ]; then
          echo '‚ùå ERROR: JWT_SECRET must be at least 64 characters for production'
          exit 1
        fi
        
        echo '‚úÖ Production initialization complete!'
      "
    volumes:
      - ./ssl-certs:/ssl-certs
      - ./nginx:/nginx
    networks:
      - secure-notes-network

# Production-specific volumes with backup considerations
volumes:
  postgres_prod_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${POSTGRES_DATA_PATH:-/var/lib/secure-notes/postgres}
  redis_prod_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${REDIS_DATA_PATH:-/var/lib/secure-notes/redis}