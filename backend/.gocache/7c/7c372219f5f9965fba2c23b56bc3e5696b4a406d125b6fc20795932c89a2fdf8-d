//line /home/rasmus/repos/notes/backend/main.go:1:1
// main.go - Complete secure backend with automatic PostgreSQL setup
package main; import _cover_atomic_ "sync/atomic"; import _ "runtime/coverage"

import (
	"context"
	"crypto/rand"
	"crypto/subtle"
	"database/sql"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
	"github.com/gofiber/fiber/v2/middleware/helmet"
	"github.com/gofiber/fiber/v2/middleware/limiter"
	"github.com/gofiber/fiber/v2/middleware/logger"
	"github.com/gofiber/fiber/v2/middleware/recover"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgxpool"
	_ "github.com/jackc/pgx/v5/stdlib"
	"github.com/redis/go-redis/v9"
	"golang.org/x/crypto/argon2"
	"golang.org/x/crypto/chacha20poly1305"
)

// AUTOMATIC DATABASE SETUP - Runs migrations on startup
const DatabaseSchema = `
-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";

-- Users table with encrypted fields
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    email_encrypted BYTEA NOT NULL, -- Encrypted email for privacy
    password_hash TEXT NOT NULL, -- Argon2id hash
    salt BYTEA NOT NULL,
    master_key_encrypted BYTEA NOT NULL, -- User's encrypted master key
    public_key BYTEA, -- For sharing encrypted notes
    private_key_encrypted BYTEA, -- Encrypted with user's derived key
    mfa_secret_encrypted BYTEA, -- Encrypted TOTP secret
    mfa_enabled BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    last_login TIMESTAMPTZ,
    failed_attempts INT DEFAULT 0,
    locked_until TIMESTAMPTZ
);

-- Workspace table
CREATE TABLE IF NOT EXISTS workspaces (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name_encrypted BYTEA NOT NULL, -- Encrypted workspace name
    owner_id UUID REFERENCES users(id) ON DELETE CASCADE,
    encryption_key_encrypted BYTEA NOT NULL, -- Workspace key encrypted with owner's key
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Notes table with full encryption
CREATE TABLE IF NOT EXISTS notes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workspace_id UUID REFERENCES workspaces(id) ON DELETE CASCADE,
    title_encrypted BYTEA NOT NULL, -- Encrypted title
    content_encrypted BYTEA NOT NULL, -- Encrypted content
    content_hash BYTEA NOT NULL, -- For integrity verification
    parent_id UUID REFERENCES notes(id) ON DELETE CASCADE,
    position INT DEFAULT 0,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    deleted_at TIMESTAMPTZ,
    version INT DEFAULT 1
);

-- Encrypted search index (searchable encryption)
CREATE TABLE IF NOT EXISTS search_index (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    note_id UUID REFERENCES notes(id) ON DELETE CASCADE,
    keyword_hash BYTEA NOT NULL, -- HMAC of keyword
    position INT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Collaboration table for shared notes
CREATE TABLE IF NOT EXISTS collaborations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    note_id UUID REFERENCES notes(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    permission TEXT CHECK (permission IN ('read', 'write', 'admin')),
    key_encrypted BYTEA NOT NULL, -- Note key encrypted with user's public key
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(note_id, user_id)
);

-- Session management with encryption
CREATE TABLE IF NOT EXISTS sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    token_hash BYTEA NOT NULL UNIQUE, -- SHA-256 hash of session token
    ip_address_encrypted BYTEA,
    user_agent_encrypted BYTEA,
    expires_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Audit log for security
CREATE TABLE IF NOT EXISTS audit_log (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id),
    action TEXT NOT NULL,
    resource_type TEXT,
    resource_id UUID,
    ip_address_encrypted BYTEA,
    user_agent_encrypted BYTEA,
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- File attachments with encryption
CREATE TABLE IF NOT EXISTS attachments (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    note_id UUID REFERENCES notes(id) ON DELETE CASCADE,
    filename_encrypted BYTEA NOT NULL,
    content_encrypted BYTEA NOT NULL, -- Store encrypted files in DB for simplicity
    mime_type TEXT,
    size_bytes BIGINT,
    checksum BYTEA NOT NULL, -- SHA-256 of encrypted content
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Encryption keys rotation table
CREATE TABLE IF NOT EXISTS key_rotations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    old_key_hash BYTEA NOT NULL,
    new_key_hash BYTEA NOT NULL,
    items_rotated INT DEFAULT 0,
    completed BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    completed_at TIMESTAMPTZ
);

-- Tags table for organizing notes
CREATE TABLE IF NOT EXISTS tags (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    name_encrypted BYTEA NOT NULL, -- Encrypted tag name
    color VARCHAR(7) DEFAULT '#3b82f6', -- Hex color code
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(user_id, name_encrypted) -- Prevent duplicate tag names per user
);

-- Junction table for note-tag relationships
CREATE TABLE IF NOT EXISTS note_tags (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    note_id UUID REFERENCES notes(id) ON DELETE CASCADE,
    tag_id UUID REFERENCES tags(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(note_id, tag_id) -- Prevent duplicate assignments
);

-- Functions for automatic updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Apply updated_at triggers
DO $$ 
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_users_updated_at') THEN
        CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_workspaces_updated_at') THEN
        CREATE TRIGGER update_workspaces_updated_at BEFORE UPDATE ON workspaces 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_notes_updated_at') THEN
        CREATE TRIGGER update_notes_updated_at BEFORE UPDATE ON notes 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
    END IF;
    
    IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_tags_updated_at') THEN
        CREATE TRIGGER update_tags_updated_at BEFORE UPDATE ON tags 
            FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
    END IF;
END $$;

-- Session cleanup function
CREATE OR REPLACE FUNCTION cleanup_expired_sessions()
RETURNS void AS $$
BEGIN
    DELETE FROM sessions WHERE expires_at < NOW();
END;
$$ LANGUAGE plpgsql;

-- Cleanup old deleted notes function (30 days)
CREATE OR REPLACE FUNCTION cleanup_old_deleted_notes()
RETURNS void AS $$
BEGIN
    DELETE FROM notes WHERE deleted_at IS NOT NULL AND deleted_at < NOW() - INTERVAL '30 days';
END;
$$ LANGUAGE plpgsql;

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_notes_workspace ON notes(workspace_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_notes_parent ON notes(parent_id);
CREATE INDEX IF NOT EXISTS idx_notes_created ON notes(created_by, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_search_keyword ON search_index(keyword_hash);

CREATE INDEX IF NOT EXISTS idx_sessions_user ON sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_sessions_expires ON sessions(expires_at);

CREATE INDEX IF NOT EXISTS idx_audit_user ON audit_log(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_audit_action ON audit_log(action, created_at DESC);

-- Tags indexes
CREATE INDEX IF NOT EXISTS idx_tags_user ON tags(user_id);
CREATE INDEX IF NOT EXISTS idx_note_tags_note ON note_tags(note_id);
CREATE INDEX IF NOT EXISTS idx_note_tags_tag ON note_tags(tag_id);

-- Note: Cleanup jobs run automatically via background service every 24 hours
`

// Configuration with secure defaults
type Config struct {
	DatabaseURL      string
	RedisURL         string
	RedisPassword    string
	JWTSecret        []byte
	EncryptionKey    []byte
	Port             string
	AllowedOrigins   []string
	MaxLoginAttempts int
	LockoutDuration  time.Duration
	SessionDuration  time.Duration
}

func LoadConfig() *Config {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__0[0], 7) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__0[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__0[2], 0) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__0[3], 1);
	// Generate secure random keys if not provided
	jwtSecret := os.Getenv("JWT_SECRET")
	if jwtSecret == "" {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__0[7], 1);
		key := make([]byte, 64)
		rand.Read(key)
		jwtSecret = base64.StdEncoding.EncodeToString(key)
		log.Println("Generated new JWT secret")
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__0[4], 1);encKey := os.Getenv("SERVER_ENCRYPTION_KEY")
	if encKey == "" {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__0[8], 1);
		key := make([]byte, 32)
		rand.Read(key)
		encKey = base64.StdEncoding.EncodeToString(key)
		log.Println("Generated new server encryption key")
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__0[5], 1);dbURL := os.Getenv("DATABASE_URL")
	if dbURL == "" {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__0[9], 1);
		dbURL = "postgres://postgres:postgres@localhost:5432/notes?sslmode=disable"
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__0[6], 1);return &Config{
		DatabaseURL:      dbURL,
		RedisURL:         getEnvOrDefault("REDIS_URL", "localhost:6379"),
		RedisPassword:    os.Getenv("REDIS_PASSWORD"),
		JWTSecret:        []byte(jwtSecret),
		EncryptionKey:    []byte(encKey),
		Port:             getEnvOrDefault("PORT", "8080"),
		AllowedOrigins:   strings.Split(getEnvOrDefault("CORS_ORIGINS", "https://localhost:3000"), ","),
		MaxLoginAttempts: 5,
		LockoutDuration:  15 * time.Minute,
		SessionDuration:  24 * time.Hour,
	}
}

func getEnvOrDefault(key, defaultValue string) string {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__1[0], 3) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__1[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__1[2], 1) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__1[3], 1);
	if value := os.Getenv(key); value != "" {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__1[5], 1);
		return value
	}
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__1[4], 1);return defaultValue
}

// Crypto Service for server-side encryption
type CryptoService struct {
	serverKey []byte
}

func NewCryptoService(key []byte) *CryptoService {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__2[0], 1) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__2[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__2[2], 2) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__2[3], 1);
	return &CryptoService{serverKey: key}
}

func (c *CryptoService) Encrypt(plaintext []byte) ([]byte, error) {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__3[0], 5) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__3[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__3[2], 3) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__3[3], 1);
	aead, err := chacha20poly1305.NewX(c.serverKey[:32])
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__3[6], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__3[4], 1);nonce := make([]byte, aead.NonceSize())
	if _, err := rand.Read(nonce); err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__3[7], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__3[5], 1);ciphertext := aead.Seal(nil, nonce, plaintext, nil)
	return append(nonce, ciphertext...), nil
}

func (c *CryptoService) Decrypt(ciphertext []byte) ([]byte, error) {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__4[0], 5) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__4[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__4[2], 4) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__4[3], 1);
	aead, err := chacha20poly1305.NewX(c.serverKey[:32])
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__4[6], 1);
		return nil, err
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__4[4], 1);if len(ciphertext) < aead.NonceSize() {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__4[7], 1);
		return nil, fmt.Errorf("ciphertext too short")
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__4[5], 1);nonce := ciphertext[:aead.NonceSize()]
	ciphertext = ciphertext[aead.NonceSize():]

	return aead.Open(nil, nonce, ciphertext, nil)
}

// Secure password hashing with Argon2id
func HashPassword(password string, salt []byte) string {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__5[0], 1) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__5[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__5[2], 5) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__5[3], 1);
	hash := argon2.IDKey([]byte(password), salt, 3, 64*1024, 4, 32)
	b64Salt := base64.RawStdEncoding.EncodeToString(salt)
	b64Hash := base64.RawStdEncoding.EncodeToString(hash)
	return fmt.Sprintf("$argon2id$v=%d$m=%d,t=%d,p=%d$%s$%s",
		argon2.Version, 64*1024, 3, 4, b64Salt, b64Hash)
}

func VerifyPassword(password, encodedHash string) bool {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__6[0], 3) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__6[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__6[2], 6) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__6[3], 1);
	parts := strings.Split(encodedHash, "$")
	if len(parts) != 6 {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__6[5], 1);
		return false
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__6[4], 1);salt, _ := base64.RawStdEncoding.DecodeString(parts[4])
	hash, _ := base64.RawStdEncoding.DecodeString(parts[5])

	comparisonHash := argon2.IDKey([]byte(password), salt, 3, 64*1024, 4, 32)
	return subtle.ConstantTimeCompare(hash, comparisonHash) == 1
}

// Database setup and migration runner
func SetupDatabase(dbURL string) (*pgxpool.Pool, error) {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__7[0], 9) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__7[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__7[2], 7) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__7[3], 1);
	// Connect to postgres to create database if needed
	tempURL := strings.Replace(dbURL, "/notes", "/postgres", 1)
	db, err := sql.Open("pgx", tempURL)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__7[8], 1);
		return nil, fmt.Errorf("failed to connect to postgres: %w", err)
	}
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__7[4], 1);defer db.Close()

	// Create database if not exists
	_, err = db.Exec("CREATE DATABASE notes")
	if err != nil && !strings.Contains(err.Error(), "already exists") {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__7[9], 1);
		log.Printf("Note: Database might already exist: %v", err)
	}

	// Connect to the actual database
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__7[5], 1);ctx := context.Background()
	pool, err := pgxpool.New(ctx, dbURL)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__7[10], 1);
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	// Run migrations
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__7[6], 1);log.Println("Running database migrations...")
	_, err = pool.Exec(ctx, DatabaseSchema)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__7[11], 1);
		return nil, fmt.Errorf("failed to run migrations: %w", err)
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__7[7], 1);log.Println("Database setup completed successfully")
	return pool, nil
}

// Database interface for dependency injection and testing
type Database interface {
	QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row
	Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error)
	Exec(ctx context.Context, sql string, args ...interface{}) (pgconn.CommandTag, error)
	Begin(ctx context.Context) (pgx.Tx, error)
}

// Auth handlers
type AuthHandler struct {
	db     Database
	crypto *CryptoService
	config *Config
}

type RegisterRequest struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required,min=12"`
}

type LoginRequest struct {
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required"`
	MFACode  string `json:"mfa_code,omitempty"`
}

func (h *AuthHandler) Register(c *fiber.Ctx) error {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__8[0], 19) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__8[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__8[2], 8) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[3], 1);
	// Check if registration is enabled
	enableRegistration := getEnvOrDefault("ENABLE_REGISTRATION", "true")
	if enableRegistration != "true" {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[12], 1);
		return c.Status(403).JSON(fiber.Map{"error": "Registration is currently disabled"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[4], 1);var req RegisterRequest
	if err := c.BodyParser(&req); err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[13], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid request"})
	}

	// Validate password requirements
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[5], 1);if len(req.Password) < 12 {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[14], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Password must be at least 12 characters long"})
	}

	// Generate salt and hash password
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[6], 1);salt := make([]byte, 32)
	rand.Read(salt)
	passwordHash := HashPassword(req.Password, salt)

	// Generate user's master encryption key
	masterKey := make([]byte, 32)
	rand.Read(masterKey)

	// Derive key from password to encrypt master key
	userKey := argon2.IDKey([]byte(req.Password), salt, 1, 64*1024, 4, 32)

	// Encrypt master key with user's derived key
	aead, _ := chacha20poly1305.NewX(userKey)
	nonce := make([]byte, aead.NonceSize())
	rand.Read(nonce)
	encryptedMasterKey := aead.Seal(nonce, nonce, masterKey, nil)

	// Encrypt email for storage
	encryptedEmail, _ := h.crypto.Encrypt([]byte(req.Email))

	// Start transaction
	ctx := context.Background()
	tx, err := h.db.Begin(ctx)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[15], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Database error"})
	}
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[7], 1);defer tx.Rollback(ctx)

	// Create user
	var userID uuid.UUID
	err = tx.QueryRow(ctx, `
        INSERT INTO users (email, email_encrypted, password_hash, salt, master_key_encrypted)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id`,
		req.Email, encryptedEmail, passwordHash, salt, encryptedMasterKey,
	).Scan(&userID)

	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[16], 1);
		if strings.Contains(err.Error(), "duplicate") {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[18], 1);
			return c.Status(409).JSON(fiber.Map{"error": "Email already registered"})
		}
		_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[17], 1);return c.Status(500).JSON(fiber.Map{"error": "Registration failed"})
	}

	// Create default workspace
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[8], 1);workspaceName, _ := h.crypto.Encrypt([]byte("My Workspace"))
	workspaceKey := make([]byte, 32)
	rand.Read(workspaceKey)

	// Encrypt workspace key with user's master key
	encryptedWorkspaceKey, _ := h.crypto.Encrypt(workspaceKey)

	var workspaceID uuid.UUID
	err = tx.QueryRow(ctx, `
        INSERT INTO workspaces (name_encrypted, owner_id, encryption_key_encrypted)
        VALUES ($1, $2, $3)
        RETURNING id`,
		workspaceName, userID, encryptedWorkspaceKey,
	).Scan(&workspaceID)

	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[19], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Failed to create workspace"})
	}

	// Commit transaction
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[9], 1);if err = tx.Commit(ctx); err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[20], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Registration failed"})
	}

	// Log audit event
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[10], 1);h.logAudit(ctx, userID, "user.registered", "user", userID, c)

	// Generate session token
	token, err := h.generateToken(userID)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[21], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Token generation failed"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__8[11], 1);return c.Status(201).JSON(fiber.Map{
		"message":      "Registration successful",
		"token":        token,
		"user_id":      userID,
		"workspace_id": workspaceID,
	})
}

func (h *AuthHandler) Login(c *fiber.Ctx) error {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__9[0], 18) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__9[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__9[2], 9) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[3], 1);
	var req LoginRequest
	if err := c.BodyParser(&req); err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[11], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid request"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[4], 1);ctx := context.Background()

	// Get user
	var userID uuid.UUID
	var passwordHash string
	var failedAttempts int
	var lockedUntil *time.Time
	var mfaEnabled bool
	var mfaSecret []byte

	err := h.db.QueryRow(ctx, `
        SELECT id, password_hash, failed_attempts, locked_until, mfa_enabled, mfa_secret_encrypted
        FROM users WHERE email = $1`,
		req.Email,
	).Scan(&userID, &passwordHash, &failedAttempts, &lockedUntil, &mfaEnabled, &mfaSecret)

	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[12], 1);
		return c.Status(401).JSON(fiber.Map{"error": "Invalid credentials"})
	}

	// Check if account is locked
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[5], 1);if lockedUntil != nil && lockedUntil.After(time.Now()) {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[13], 1);
		return c.Status(403).JSON(fiber.Map{"error": "Account locked. Try again later."})
	}

	// Verify password
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[6], 1);if !VerifyPassword(req.Password, passwordHash) {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[14], 1);
		// Increment failed attempts
		failedAttempts++
		if failedAttempts >= h.config.MaxLoginAttempts {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[16], 1);
			lockUntil := time.Now().Add(h.config.LockoutDuration)
			h.db.Exec(ctx, `
                UPDATE users SET failed_attempts = $1, locked_until = $2 
                WHERE id = $3`,
				failedAttempts, lockUntil, userID,
			)
			h.logAudit(ctx, userID, "login.locked", "user", userID, c)
			return c.Status(403).JSON(fiber.Map{"error": "Account locked due to too many failed attempts"})
		}

		_cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[15], 1);h.db.Exec(ctx, `UPDATE users SET failed_attempts = $1 WHERE id = $2`, failedAttempts, userID)
		h.logAudit(ctx, userID, "login.failed", "user", userID, c)
		return c.Status(401).JSON(fiber.Map{"error": "Invalid credentials"})
	}

	// Verify MFA if enabled
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[7], 1);if mfaEnabled {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[17], 1);
		if req.MFACode == "" {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[18], 1);
			return c.Status(200).JSON(fiber.Map{"mfa_required": true})
		}
		// Verify TOTP code here (implement TOTP verification)
	}

	// Reset failed attempts and update last login
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[8], 1);h.db.Exec(ctx, `
        UPDATE users SET failed_attempts = 0, locked_until = NULL, last_login = NOW() 
        WHERE id = $1`,
		userID,
	)

	// Generate session
	sessionToken := make([]byte, 32)
	rand.Read(sessionToken)
	sessionTokenStr := hex.EncodeToString(sessionToken)

	// Hash token for storage
	tokenHash := argon2.IDKey(sessionToken, []byte("session"), 1, 64*1024, 4, 32)

	// Encrypt IP and user agent
	encryptedIP, _ := h.crypto.Encrypt([]byte(c.IP()))
	encryptedUA, _ := h.crypto.Encrypt([]byte(c.Get("User-Agent")))

	// Store session
	_, err = h.db.Exec(ctx, `
        INSERT INTO sessions (user_id, token_hash, ip_address_encrypted, user_agent_encrypted, expires_at)
        VALUES ($1, $2, $3, $4, $5)`,
		userID, tokenHash, encryptedIP, encryptedUA, time.Now().Add(h.config.SessionDuration),
	)

	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[19], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Session creation failed"})
	}

	// Log successful login
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[9], 1);h.logAudit(ctx, userID, "login.success", "user", userID, c)

	// Generate JWT token
	token, err := h.generateToken(userID)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[20], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Token generation failed"})
	}

	// Get workspace
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__9[10], 1);var workspaceID uuid.UUID
	h.db.QueryRow(ctx, `SELECT id FROM workspaces WHERE owner_id = $1 LIMIT 1`, userID).Scan(&workspaceID)

	return c.JSON(fiber.Map{
		"token":        token,
		"session":      sessionTokenStr,
		"user_id":      userID,
		"workspace_id": workspaceID,
	})
}

func (h *AuthHandler) generateToken(userID uuid.UUID) (string, error) {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__10[0], 1) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__10[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__10[2], 10) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__10[3], 1);
	claims := jwt.MapClaims{
		"user_id": userID.String(),
		"exp":     time.Now().Add(24 * time.Hour).Unix(),
		"iat":     time.Now().Unix(),
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS512, claims)
	return token.SignedString(h.config.JWTSecret)
}

func (h *AuthHandler) logAudit(ctx context.Context, userID uuid.UUID, action, resourceType string, resourceID uuid.UUID, c *fiber.Ctx) {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__11[0], 1) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__11[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__11[2], 11) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__11[3], 1);
	encryptedIP, _ := h.crypto.Encrypt([]byte(c.IP()))
	encryptedUA, _ := h.crypto.Encrypt([]byte(c.Get("User-Agent")))

	h.db.Exec(ctx, `
        INSERT INTO audit_log (user_id, action, resource_type, resource_id, ip_address_encrypted, user_agent_encrypted)
        VALUES ($1, $2, $3, $4, $5, $6)`,
		userID, action, resourceType, resourceID, encryptedIP, encryptedUA,
	)
}

// Notes Handler
type NotesHandler struct {
	db     Database
	crypto *CryptoService
}

type CreateNoteRequest struct {
	TitleEncrypted   string `json:"title_encrypted" validate:"required"`
	ContentEncrypted string `json:"content_encrypted" validate:"required"`
}

type UpdateNoteRequest struct {
	TitleEncrypted   string `json:"title_encrypted" validate:"required"`
	ContentEncrypted string `json:"content_encrypted" validate:"required"`
}

func (h *NotesHandler) GetNotes(c *fiber.Ctx) error {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__12[0], 9) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__12[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__12[2], 12) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__12[3], 1);
	userID := c.Locals("user_id").(uuid.UUID)
	ctx := context.Background()

	// Get user's default workspace
	var workspaceID uuid.UUID
	err := h.db.QueryRow(ctx, `SELECT id FROM workspaces WHERE owner_id = $1 LIMIT 1`, userID).Scan(&workspaceID)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__12[7], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Failed to get workspace"})
	}

	// Get notes from workspace
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__12[4], 1);rows, err := h.db.Query(ctx, `
		SELECT id, title_encrypted, content_encrypted, created_at, updated_at
		FROM notes 
		WHERE workspace_id = $1 AND deleted_at IS NULL
		ORDER BY updated_at DESC`,
		workspaceID)
	
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__12[8], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Failed to fetch notes"})
	}
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__12[5], 1);defer rows.Close()

	notes := []fiber.Map{}
	for rows.Next() {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__12[9], 1);
		var id uuid.UUID
		var titleEnc, contentEnc []byte
		var createdAt, updatedAt time.Time

		if err := rows.Scan(&id, &titleEnc, &contentEnc, &createdAt, &updatedAt); err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__12[11], 1);
			continue
		}

		_cover_atomic_.AddUint32(&goCover_5a9262f9c733__12[10], 1);notes = append(notes, fiber.Map{
			"id":                id,
			"title_encrypted":   base64.StdEncoding.EncodeToString(titleEnc),
			"content_encrypted": base64.StdEncoding.EncodeToString(contentEnc),
			"created_at":        createdAt,
			"updated_at":        updatedAt,
		})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__12[6], 1);return c.JSON(fiber.Map{"notes": notes})
}

func (h *NotesHandler) GetNote(c *fiber.Ctx) error {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__13[0], 5) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__13[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__13[2], 13) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__13[3], 1);
	userID := c.Locals("user_id").(uuid.UUID)
	noteID, err := uuid.Parse(c.Params("id"))
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__13[6], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid note ID"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__13[4], 1);ctx := context.Background()
	var id uuid.UUID
	var titleEnc, contentEnc []byte
	var createdAt, updatedAt time.Time

	err = h.db.QueryRow(ctx, `
		SELECT n.id, n.title_encrypted, n.content_encrypted, n.created_at, n.updated_at
		FROM notes n
		JOIN workspaces w ON n.workspace_id = w.id
		WHERE n.id = $1 AND w.owner_id = $2 AND n.deleted_at IS NULL`,
		noteID, userID).Scan(&id, &titleEnc, &contentEnc, &createdAt, &updatedAt)

	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__13[7], 1);
		return c.Status(404).JSON(fiber.Map{"error": "Note not found"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__13[5], 1);return c.JSON(fiber.Map{
		"id":                id,
		"title_encrypted":   base64.StdEncoding.EncodeToString(titleEnc),
		"content_encrypted": base64.StdEncoding.EncodeToString(contentEnc),
		"created_at":        createdAt,
		"updated_at":        updatedAt,
	})
}

func (h *NotesHandler) CreateNote(c *fiber.Ctx) error {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__14[0], 11) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__14[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__14[2], 14) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__14[3], 1);
	userID := c.Locals("user_id").(uuid.UUID)
	var req CreateNoteRequest
	if err := c.BodyParser(&req); err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__14[9], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid request"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__14[4], 1);ctx := context.Background()

	// Get user's default workspace
	var workspaceID uuid.UUID
	err := h.db.QueryRow(ctx, `SELECT id FROM workspaces WHERE owner_id = $1 LIMIT 1`, userID).Scan(&workspaceID)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__14[10], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Failed to get workspace"})
	}

	// Decode encrypted data
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__14[5], 1);titleEnc, err := base64.StdEncoding.DecodeString(req.TitleEncrypted)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__14[11], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid title encryption"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__14[6], 1);contentEnc, err := base64.StdEncoding.DecodeString(req.ContentEncrypted)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__14[12], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid content encryption"})
	}

	// Create content hash for integrity
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__14[7], 1);contentHash := argon2.IDKey(contentEnc, []byte("integrity"), 1, 64*1024, 4, 32)

	// Create note
	var noteID uuid.UUID
	err = h.db.QueryRow(ctx, `
		INSERT INTO notes (workspace_id, title_encrypted, content_encrypted, content_hash, created_by)
		VALUES ($1, $2, $3, $4, $5)
		RETURNING id`,
		workspaceID, titleEnc, contentEnc, contentHash, userID).Scan(&noteID)

	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__14[13], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Failed to create note"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__14[8], 1);return c.Status(201).JSON(fiber.Map{
		"id":      noteID,
		"message": "Note created successfully",
	})
}

func (h *NotesHandler) UpdateNote(c *fiber.Ctx) error {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__15[0], 13) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__15[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__15[2], 15) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__15[3], 1);
	userID := c.Locals("user_id").(uuid.UUID)
	noteID, err := uuid.Parse(c.Params("id"))
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__15[10], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid note ID"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__15[4], 1);var req UpdateNoteRequest
	if err := c.BodyParser(&req); err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__15[11], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid request"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__15[5], 1);ctx := context.Background()

	// Decode encrypted data
	titleEnc, err := base64.StdEncoding.DecodeString(req.TitleEncrypted)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__15[12], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid title encryption"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__15[6], 1);contentEnc, err := base64.StdEncoding.DecodeString(req.ContentEncrypted)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__15[13], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid content encryption"})
	}

	// Create content hash for integrity
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__15[7], 1);contentHash := argon2.IDKey(contentEnc, []byte("integrity"), 1, 64*1024, 4, 32)

	// Update note
	result, err := h.db.Exec(ctx, `
		UPDATE notes 
		SET title_encrypted = $1, content_encrypted = $2, content_hash = $3, updated_at = NOW()
		FROM workspaces w
		WHERE notes.id = $4 AND notes.workspace_id = w.id AND w.owner_id = $5 AND notes.deleted_at IS NULL`,
		titleEnc, contentEnc, contentHash, noteID, userID)

	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__15[14], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Failed to update note"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__15[8], 1);if result.RowsAffected() == 0 {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__15[15], 1);
		return c.Status(404).JSON(fiber.Map{"error": "Note not found"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__15[9], 1);return c.JSON(fiber.Map{"message": "Note updated successfully"})
}

func (h *NotesHandler) DeleteNote(c *fiber.Ctx) error {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__16[0], 7) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__16[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__16[2], 16) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__16[3], 1);
	userID := c.Locals("user_id").(uuid.UUID)
	noteID, err := uuid.Parse(c.Params("id"))
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__16[7], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid note ID"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__16[4], 1);ctx := context.Background()

	// Soft delete the note
	result, err := h.db.Exec(ctx, `
		UPDATE notes 
		SET deleted_at = NOW()
		FROM workspaces w
		WHERE notes.id = $1 AND notes.workspace_id = w.id AND w.owner_id = $2 AND notes.deleted_at IS NULL`,
		noteID, userID)

	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__16[8], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Failed to delete note"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__16[5], 1);if result.RowsAffected() == 0 {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__16[9], 1);
		return c.Status(404).JSON(fiber.Map{"error": "Note not found"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__16[6], 1);return c.JSON(fiber.Map{"message": "Note moved to trash successfully"})
}

func (h *NotesHandler) GetTrash(c *fiber.Ctx) error {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__17[0], 9) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__17[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__17[2], 17) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__17[3], 1);
	userID := c.Locals("user_id").(uuid.UUID)
	ctx := context.Background()

	// Get user's default workspace
	var workspaceID uuid.UUID
	err := h.db.QueryRow(ctx, `SELECT id FROM workspaces WHERE owner_id = $1 LIMIT 1`, userID).Scan(&workspaceID)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__17[7], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Failed to get workspace"})
	}

	// Get deleted notes from workspace
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__17[4], 1);rows, err := h.db.Query(ctx, `
		SELECT id, title_encrypted, content_encrypted, deleted_at, updated_at
		FROM notes 
		WHERE workspace_id = $1 AND deleted_at IS NOT NULL
		ORDER BY deleted_at DESC`,
		workspaceID)
	
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__17[8], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Failed to fetch trash"})
	}
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__17[5], 1);defer rows.Close()

	trashedNotes := []fiber.Map{}
	for rows.Next() {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__17[9], 1);
		var id uuid.UUID
		var titleEnc, contentEnc []byte
		var deletedAt, updatedAt time.Time

		if err := rows.Scan(&id, &titleEnc, &contentEnc, &deletedAt, &updatedAt); err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__17[11], 1);
			continue
		}

		_cover_atomic_.AddUint32(&goCover_5a9262f9c733__17[10], 1);trashedNotes = append(trashedNotes, fiber.Map{
			"id":                id,
			"title_encrypted":   base64.StdEncoding.EncodeToString(titleEnc),
			"content_encrypted": base64.StdEncoding.EncodeToString(contentEnc),
			"deleted_at":        deletedAt,
			"updated_at":        updatedAt,
		})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__17[6], 1);return c.JSON(fiber.Map{"notes": trashedNotes})
}

func (h *NotesHandler) RestoreNote(c *fiber.Ctx) error {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__18[0], 7) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__18[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__18[2], 18) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__18[3], 1);
	userID := c.Locals("user_id").(uuid.UUID)
	noteID, err := uuid.Parse(c.Params("id"))
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__18[7], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid note ID"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__18[4], 1);ctx := context.Background()

	// Restore the note (set deleted_at to NULL)
	result, err := h.db.Exec(ctx, `
		UPDATE notes 
		SET deleted_at = NULL, updated_at = NOW()
		FROM workspaces w
		WHERE notes.id = $1 AND notes.workspace_id = w.id AND w.owner_id = $2 AND notes.deleted_at IS NOT NULL`,
		noteID, userID)

	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__18[8], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Failed to restore note"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__18[5], 1);if result.RowsAffected() == 0 {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__18[9], 1);
		return c.Status(404).JSON(fiber.Map{"error": "Note not found in trash"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__18[6], 1);return c.JSON(fiber.Map{"message": "Note restored successfully"})
}

func (h *NotesHandler) PermanentlyDeleteNote(c *fiber.Ctx) error {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__19[0], 7) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__19[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__19[2], 19) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__19[3], 1);
	userID := c.Locals("user_id").(uuid.UUID)
	noteID, err := uuid.Parse(c.Params("id"))
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__19[7], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid note ID"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__19[4], 1);ctx := context.Background()

	// Permanently delete the note
	result, err := h.db.Exec(ctx, `
		DELETE FROM notes 
		USING workspaces w
		WHERE notes.id = $1 AND notes.workspace_id = w.id AND w.owner_id = $2 AND notes.deleted_at IS NOT NULL`,
		noteID, userID)

	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__19[8], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Failed to permanently delete note"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__19[5], 1);if result.RowsAffected() == 0 {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__19[9], 1);
		return c.Status(404).JSON(fiber.Map{"error": "Note not found in trash"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__19[6], 1);return c.JSON(fiber.Map{"message": "Note permanently deleted successfully"})
}

// Tags Handler
type TagsHandler struct {
	db     Database
	crypto *CryptoService
}

type CreateTagRequest struct {
	Name  string `json:"name" validate:"required"`
	Color string `json:"color,omitempty"`
}

type AssignTagRequest struct {
	TagID string `json:"tag_id" validate:"required"`
}

func (h *TagsHandler) GetTags(c *fiber.Ctx) error {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__20[0], 9) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__20[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__20[2], 20) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__20[3], 1);
	userID := c.Locals("user_id").(uuid.UUID)
	ctx := context.Background()

	// Get user's tags
	rows, err := h.db.Query(ctx, `
		SELECT id, name_encrypted, color, created_at, updated_at
		FROM tags 
		WHERE user_id = $1
		ORDER BY name_encrypted ASC`,
		userID)
	
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__20[6], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Failed to fetch tags"})
	}
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__20[4], 1);defer rows.Close()

	tags := []fiber.Map{}
	for rows.Next() {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__20[7], 1);
		var id uuid.UUID
		var nameEnc []byte
		var color string
		var createdAt, updatedAt time.Time

		if err := rows.Scan(&id, &nameEnc, &color, &createdAt, &updatedAt); err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__20[10], 1);
			continue
		}

		// Decrypt tag name
		_cover_atomic_.AddUint32(&goCover_5a9262f9c733__20[8], 1);name, err := h.crypto.Decrypt(nameEnc)
		if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__20[11], 1);
			continue
		}

		_cover_atomic_.AddUint32(&goCover_5a9262f9c733__20[9], 1);tags = append(tags, fiber.Map{
			"id":         id,
			"name":       string(name),
			"color":      color,
			"created_at": createdAt,
			"updated_at": updatedAt,
		})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__20[5], 1);return c.JSON(fiber.Map{"tags": tags})
}

func (h *TagsHandler) CreateTag(c *fiber.Ctx) error {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__21[0], 13) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__21[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__21[2], 21) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__21[3], 1);
	userID := c.Locals("user_id").(uuid.UUID)
	var req CreateTagRequest
	if err := c.BodyParser(&req); err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__21[9], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid request"})
	}

	// Validate color format (if provided)
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__21[4], 1);if req.Color != "" && !isValidHexColor(req.Color) {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__21[10], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid color format"})
	}

	// Set default color if not provided
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__21[5], 1);if req.Color == "" {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__21[11], 1);
		req.Color = "#3b82f6"
	}

	// Encrypt tag name
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__21[6], 1);encryptedName, err := h.crypto.Encrypt([]byte(req.Name))
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__21[12], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Failed to encrypt tag name"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__21[7], 1);ctx := context.Background()

	// Create tag
	var tagID uuid.UUID
	err = h.db.QueryRow(ctx, `
		INSERT INTO tags (user_id, name_encrypted, color)
		VALUES ($1, $2, $3)
		RETURNING id`,
		userID, encryptedName, req.Color).Scan(&tagID)

	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__21[13], 1);
		if strings.Contains(err.Error(), "duplicate") {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__21[15], 1);
			return c.Status(409).JSON(fiber.Map{"error": "Tag with this name already exists"})
		}
		_cover_atomic_.AddUint32(&goCover_5a9262f9c733__21[14], 1);return c.Status(500).JSON(fiber.Map{"error": "Failed to create tag"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__21[8], 1);return c.Status(201).JSON(fiber.Map{
		"id":      tagID,
		"message": "Tag created successfully",
	})
}

func (h *TagsHandler) DeleteTag(c *fiber.Ctx) error {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__22[0], 7) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__22[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__22[2], 22) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__22[3], 1);
	userID := c.Locals("user_id").(uuid.UUID)
	tagID, err := uuid.Parse(c.Params("id"))
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__22[7], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid tag ID"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__22[4], 1);ctx := context.Background()

	// Delete tag (this will cascade delete note_tags relationships)
	result, err := h.db.Exec(ctx, `
		DELETE FROM tags 
		WHERE id = $1 AND user_id = $2`,
		tagID, userID)

	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__22[8], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Failed to delete tag"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__22[5], 1);if result.RowsAffected() == 0 {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__22[9], 1);
		return c.Status(404).JSON(fiber.Map{"error": "Tag not found"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__22[6], 1);return c.JSON(fiber.Map{"message": "Tag deleted successfully"})
}

func (h *TagsHandler) AssignTagToNote(c *fiber.Ctx) error {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__23[0], 13) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__23[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__23[2], 23) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__23[3], 1);
	userID := c.Locals("user_id").(uuid.UUID)
	noteID, err := uuid.Parse(c.Params("id"))
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__23[10], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid note ID"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__23[4], 1);var req AssignTagRequest
	if err := c.BodyParser(&req); err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__23[11], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid request"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__23[5], 1);tagID, err := uuid.Parse(req.TagID)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__23[12], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid tag ID"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__23[6], 1);ctx := context.Background()

	// Verify note belongs to user
	var noteExists bool
	err = h.db.QueryRow(ctx, `
		SELECT true FROM notes n
		JOIN workspaces w ON n.workspace_id = w.id
		WHERE n.id = $1 AND w.owner_id = $2 AND n.deleted_at IS NULL`,
		noteID, userID).Scan(&noteExists)

	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__23[13], 1);
		return c.Status(404).JSON(fiber.Map{"error": "Note not found"})
	}

	// Verify tag belongs to user
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__23[7], 1);var tagExists bool
	err = h.db.QueryRow(ctx, `
		SELECT true FROM tags WHERE id = $1 AND user_id = $2`,
		tagID, userID).Scan(&tagExists)

	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__23[14], 1);
		return c.Status(404).JSON(fiber.Map{"error": "Tag not found"})
	}

	// Assign tag to note
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__23[8], 1);_, err = h.db.Exec(ctx, `
		INSERT INTO note_tags (note_id, tag_id)
		VALUES ($1, $2)
		ON CONFLICT (note_id, tag_id) DO NOTHING`,
		noteID, tagID)

	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__23[15], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Failed to assign tag"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__23[9], 1);return c.JSON(fiber.Map{"message": "Tag assigned successfully"})
}

func (h *TagsHandler) RemoveTagFromNote(c *fiber.Ctx) error {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__24[0], 9) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__24[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__24[2], 24) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__24[3], 1);
	userID := c.Locals("user_id").(uuid.UUID)
	noteID, err := uuid.Parse(c.Params("id"))
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__24[8], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid note ID"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__24[4], 1);tagID, err := uuid.Parse(c.Params("tag_id"))
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__24[9], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid tag ID"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__24[5], 1);ctx := context.Background()

	// Remove tag assignment (with user verification)
	result, err := h.db.Exec(ctx, `
		DELETE FROM note_tags 
		USING notes n, workspaces w, tags t
		WHERE note_tags.note_id = n.id 
		AND note_tags.tag_id = t.id
		AND n.workspace_id = w.id
		AND note_tags.note_id = $1 
		AND note_tags.tag_id = $2
		AND w.owner_id = $3 
		AND t.user_id = $3`,
		noteID, tagID, userID)

	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__24[10], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Failed to remove tag"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__24[6], 1);if result.RowsAffected() == 0 {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__24[11], 1);
		return c.Status(404).JSON(fiber.Map{"error": "Tag assignment not found"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__24[7], 1);return c.JSON(fiber.Map{"message": "Tag removed successfully"})
}

func (h *TagsHandler) GetNotesByTag(c *fiber.Ctx) error {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__25[0], 9) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__25[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__25[2], 25) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__25[3], 1);
	userID := c.Locals("user_id").(uuid.UUID)
	tagID, err := uuid.Parse(c.Params("id"))
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__25[7], 1);
		return c.Status(400).JSON(fiber.Map{"error": "Invalid tag ID"})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__25[4], 1);ctx := context.Background()

	// Get notes with this tag
	rows, err := h.db.Query(ctx, `
		SELECT n.id, n.title_encrypted, n.content_encrypted, n.created_at, n.updated_at
		FROM notes n
		JOIN workspaces w ON n.workspace_id = w.id
		JOIN note_tags nt ON n.id = nt.note_id
		JOIN tags t ON nt.tag_id = t.id
		WHERE t.id = $1 AND w.owner_id = $2 AND n.deleted_at IS NULL
		ORDER BY n.updated_at DESC`,
		tagID, userID)
	
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__25[8], 1);
		return c.Status(500).JSON(fiber.Map{"error": "Failed to fetch notes"})
	}
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__25[5], 1);defer rows.Close()

	notes := []fiber.Map{}
	for rows.Next() {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__25[9], 1);
		var id uuid.UUID
		var titleEnc, contentEnc []byte
		var createdAt, updatedAt time.Time

		if err := rows.Scan(&id, &titleEnc, &contentEnc, &createdAt, &updatedAt); err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__25[11], 1);
			continue
		}

		_cover_atomic_.AddUint32(&goCover_5a9262f9c733__25[10], 1);notes = append(notes, fiber.Map{
			"id":                id,
			"title_encrypted":   base64.StdEncoding.EncodeToString(titleEnc),
			"content_encrypted": base64.StdEncoding.EncodeToString(contentEnc),
			"created_at":        createdAt,
			"updated_at":        updatedAt,
		})
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__25[6], 1);return c.JSON(fiber.Map{"notes": notes})
}

func isValidHexColor(color string) bool {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__26[0], 6) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__26[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__26[2], 26) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__26[3], 1);
	if len(color) != 7 || color[0] != '#' {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__26[6], 1);
		return false
	}
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__26[4], 1);for i := 1; i < 7; i++ {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__26[7], 1);
		c := color[i]
		if !((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')) {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__26[8], 1);
			return false
		}
	}
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__26[5], 1);return true
}

// JWT Middleware
func JWTMiddleware(secret []byte) fiber.Handler {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__27[0], 14) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__27[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__27[2], 27) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__27[3], 1);
	return func(c *fiber.Ctx) error {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__27[4], 1);
		token := c.Get("Authorization")
		if token == "" {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__27[11], 1);
			return c.Status(401).JSON(fiber.Map{"error": "Missing authorization"})
		}

		_cover_atomic_.AddUint32(&goCover_5a9262f9c733__27[5], 1);token = strings.TrimPrefix(token, "Bearer ")

		parsed, err := jwt.Parse(token, func(token *jwt.Token) (interface{}, error) {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__27[12], 1);
			return secret, nil
		})

		_cover_atomic_.AddUint32(&goCover_5a9262f9c733__27[6], 1);if err != nil || !parsed.Valid {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__27[13], 1);
			return c.Status(401).JSON(fiber.Map{"error": "Invalid token"})
		}

		_cover_atomic_.AddUint32(&goCover_5a9262f9c733__27[7], 1);claims := parsed.Claims.(jwt.MapClaims)
		
		// Safely extract user_id claim
		userIDClaim, exists := claims["user_id"]
		if !exists {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__27[14], 1);
			return c.Status(401).JSON(fiber.Map{"error": "Missing user_id claim"})
		}
		
		_cover_atomic_.AddUint32(&goCover_5a9262f9c733__27[8], 1);userIDStr, ok := userIDClaim.(string)
		if !ok {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__27[15], 1);
			return c.Status(401).JSON(fiber.Map{"error": "Invalid user_id claim type"})
		}
		
		_cover_atomic_.AddUint32(&goCover_5a9262f9c733__27[9], 1);userID, err := uuid.Parse(userIDStr)
		if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__27[16], 1);
			return c.Status(401).JSON(fiber.Map{"error": "Invalid user_id format"})
		}
		
		_cover_atomic_.AddUint32(&goCover_5a9262f9c733__27[10], 1);c.Locals("user_id", userID)

		return c.Next()
	}
}

// Background cleanup service that runs every 24 hours
func startCleanupService(db Database) {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__28[0], 4) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__28[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__28[2], 28) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__28[3], 1);
	go func() {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__28[4], 1);
		ctx := context.Background()
		ticker := time.NewTicker(24 * time.Hour)
		defer ticker.Stop()

		// Run initial cleanup
		runCleanupTasks(ctx, db)

		for {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__28[5], 1);
			select {
			case <-ticker.C:_cover_atomic_.AddUint32(&goCover_5a9262f9c733__28[6], 1);
				runCleanupTasks(ctx, db)
			}
		}
	}()
}

func runCleanupTasks(ctx context.Context, db Database) {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__29[0], 9) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__29[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__29[2], 29) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__29[3], 1);
	log.Println("🧹 Running scheduled cleanup tasks...")
	
	// Clean up expired sessions
	result1, err1 := db.Exec(ctx, "SELECT cleanup_expired_sessions()")
	if err1 != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__29[7], 1);
		log.Printf("⚠️ Failed to cleanup expired sessions: %v", err1)
	} else{ _cover_atomic_.AddUint32(&goCover_5a9262f9c733__29[8], 1);{
		log.Println("✅ Cleaned up expired sessions")
	}}

	// Clean up old deleted notes (30+ days)
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__29[4], 1);result2, err2 := db.Exec(ctx, "SELECT cleanup_old_deleted_notes()")
	if err2 != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__29[9], 1);
		log.Printf("⚠️ Failed to cleanup old deleted notes: %v", err2)
	} else{ _cover_atomic_.AddUint32(&goCover_5a9262f9c733__29[10], 1);{
		log.Println("✅ Cleaned up old deleted notes")
	}}

	// Get count of deleted notes
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__29[5], 1);var deletedCount int
	db.QueryRow(ctx, "SELECT COUNT(*) FROM notes WHERE deleted_at < NOW() - INTERVAL '30 days' AND deleted_at IS NOT NULL").Scan(&deletedCount)
	
	if deletedCount > 0 {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__29[11], 1);
		log.Printf("🗑️ Permanently deleted %d notes older than 30 days", deletedCount)
	}

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__29[6], 1);log.Println("🎯 Cleanup tasks completed successfully")
	
	// Prevent unused variable warnings
	_ = result1
	_ = result2
}

func main() {_cover_atomic_.StoreUint32(&goCover_5a9262f9c733__30[0], 17) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__30[1], goCover_5a9262f9c733_P) ; _cover_atomic_.StoreUint32(&goCover_5a9262f9c733__30[2], 30) ; _cover_atomic_.AddUint32(&goCover_5a9262f9c733__30[3], 1);
	// Load configuration
	config := LoadConfig()

	// Setup database with automatic migrations
	db, err := SetupDatabase(config.DatabaseURL)
	if err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__30[9], 1);
		log.Fatal("Database setup failed:", err)
	}
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__30[4], 1);defer db.Close()

	// Setup Redis
	rdb := redis.NewClient(&redis.Options{
		Addr:     config.RedisURL,
		Password: config.RedisPassword,
		DB:       0, // use default DB
	})
	defer rdb.Close()

	// Initialize crypto service
	crypto := NewCryptoService(config.EncryptionKey)

	// Create Fiber app with security middleware
	app := fiber.New(fiber.Config{
		DisableStartupMessage: false,
		BodyLimit:             512 * 1024, // 512KB body size limit
		ErrorHandler: func(c *fiber.Ctx, err error) error {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__30[10], 1);
			code := fiber.StatusInternalServerError
			if e, ok := err.(*fiber.Error); ok {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__30[12], 1);
				code = e.Code
			}
			_cover_atomic_.AddUint32(&goCover_5a9262f9c733__30[11], 1);return c.Status(code).JSON(fiber.Map{"error": err.Error()})
		},
	})

	// Security middleware
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__30[5], 1);app.Use(recover.New())
	app.Use(logger.New())
	app.Use(helmet.New(helmet.Config{
		XSSProtection:         "1; mode=block",
		ContentTypeNosniff:    "nosniff",
		XFrameOptions:         "DENY",
		HSTSMaxAge:            31536000,
		ContentSecurityPolicy: "default-src 'self'",
		ReferrerPolicy:        "strict-origin-when-cross-origin",
	}))

	// CORS
	app.Use(cors.New(cors.Config{
		AllowOrigins:     strings.Join(config.AllowedOrigins, ","),
		AllowCredentials: true,
		AllowHeaders:     "Origin, Content-Type, Accept, Authorization",
		AllowMethods:     "GET, POST, PUT, DELETE, OPTIONS",
	}))

	// Rate limiting
	app.Use(limiter.New(limiter.Config{
		Max:        100,
		Expiration: 1 * time.Minute,
		KeyGenerator: func(c *fiber.Ctx) string {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__30[13], 1);
			return c.IP()
		},
	}))

	// Initialize handlers
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__30[6], 1);authHandler := &AuthHandler{
		db:     db,
		crypto: crypto,
		config: config,
	}

	// Public routes
	api := app.Group("/api/v1")
	api.Post("/auth/register", authHandler.Register)
	api.Post("/auth/login", authHandler.Login)

	// Health checks
	api.Get("/health", func(c *fiber.Ctx) error {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__30[14], 1);
		return c.JSON(fiber.Map{"status": "healthy", "encryption": "enabled"})
	})

	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__30[7], 1);api.Get("/ready", func(c *fiber.Ctx) error {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__30[15], 1);
		ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
		defer cancel()

		if err := db.Ping(ctx); err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__30[18], 1);
			return c.Status(503).JSON(fiber.Map{"status": "not ready", "db": "down"})
		}

		_cover_atomic_.AddUint32(&goCover_5a9262f9c733__30[16], 1);if err := rdb.Ping(ctx).Err(); err != nil {_cover_atomic_.AddUint32(&goCover_5a9262f9c733__30[19], 1);
			return c.Status(503).JSON(fiber.Map{"status": "not ready", "redis": "down"})
		}

		_cover_atomic_.AddUint32(&goCover_5a9262f9c733__30[17], 1);return c.JSON(fiber.Map{
			"status":     "ready",
			"db":         "connected",
			"redis":      "connected",
			"encryption": "active",
		})
	})

	// Notes handlers
	_cover_atomic_.AddUint32(&goCover_5a9262f9c733__30[8], 1);notesHandler := &NotesHandler{
		db:     db,
		crypto: crypto,
	}

	// Tags handlers
	tagsHandler := &TagsHandler{
		db:     db,
		crypto: crypto,
	}

	// Protected routes
	protected := api.Group("/", JWTMiddleware(config.JWTSecret))
	
	// Notes endpoints
	protected.Get("/notes", notesHandler.GetNotes)
	protected.Get("/notes/:id", notesHandler.GetNote)
	protected.Post("/notes", notesHandler.CreateNote)
	protected.Put("/notes/:id", notesHandler.UpdateNote)
	protected.Delete("/notes/:id", notesHandler.DeleteNote)
	
	// Trash endpoints
	protected.Get("/trash", notesHandler.GetTrash)
	protected.Put("/trash/:id/restore", notesHandler.RestoreNote)
	protected.Delete("/trash/:id", notesHandler.PermanentlyDeleteNote)
	
	// Tags endpoints
	protected.Get("/tags", tagsHandler.GetTags)
	protected.Post("/tags", tagsHandler.CreateTag)
	protected.Delete("/tags/:id", tagsHandler.DeleteTag)
	protected.Get("/tags/:id/notes", tagsHandler.GetNotesByTag)
	
	// Note-tag assignment endpoints
	protected.Post("/notes/:id/tags", tagsHandler.AssignTagToNote)
	protected.Delete("/notes/:id/tags/:tag_id", tagsHandler.RemoveTagFromNote)

	// Start background cleanup service
	startCleanupService(db)

	// Start server
	log.Printf("Starting secure server on port %s with full encryption", config.Port)
	log.Fatal(app.Listen(":" + config.Port))
}

var _ = _cover_atomic_.LoadUint32
